<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CoHAN2.0: hateb_local_planner Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CoHAN2.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hateb_local_planner Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1Backoff.html">Backoff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing backoff behavior for robot navigation.  <a href="classhateb__local__planner_1_1Backoff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1SetMode.html">SetMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a behavior tree action node to set planning mode.  <a href="classhateb__local__planner_1_1SetMode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1StatefulActionNodeROS.html">StatefulActionNodeROS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for stateful action nodes in the behavior tree.  <a href="classhateb__local__planner_1_1StatefulActionNodeROS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhateb__local__planner_1_1ModeInfo.html">ModeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure combining planning and prediction modes Used to configure the behavior of the local planner.  <a href="structhateb__local__planner_1_1ModeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1BackoffExitCondition.html">BackoffExitCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a condition node for managing backoff recovery behavior.  <a href="classhateb__local__planner_1_1BackoffExitCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1DualBandExitCondition.html">DualBandExitCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a condition node for dual band exit criteria.  <a href="classhateb__local__planner_1_1DualBandExitCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1IsGoalReached.html">IsGoalReached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a condition node for checking if navigation goal is reached.  <a href="classhateb__local__planner_1_1IsGoalReached.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1IsGoalUpdated.html">IsGoalUpdated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a condition node for checking if navigation goal has been updated.  <a href="classhateb__local__planner_1_1IsGoalUpdated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PassThroughCondition.html">PassThroughCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a condition node for checking passthrough scenarios.  <a href="classhateb__local__planner_1_1PassThroughCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1SingleBandExitCondition.html">SingleBandExitCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing a condition node for checking single band exit criteria.  <a href="classhateb__local__planner_1_1SingleBandExitCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1VelObsExitCondition.html">VelObsExitCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition node that checks if an obstacle (human) has stopped in the environment.  <a href="classhateb__local__planner_1_1VelObsExitCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1BaseFootprintModel.html">BaseFootprintModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines the interface for footprint/contour models.  <a href="classhateb__local__planner_1_1BaseFootprintModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PointFootprint.html">PointFootprint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1CircularFootprint.html">CircularFootprint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines the a robot/human of circular shape.  <a href="classhateb__local__planner_1_1CircularFootprint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1TwoCirclesFootprint.html">TwoCirclesFootprint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that approximates the robot/human with two shifted circles.  <a href="classhateb__local__planner_1_1TwoCirclesFootprint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1LineFootprint.html">LineFootprint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that approximates the robot/human with line segment (zero-width)  <a href="classhateb__local__planner_1_1LineFootprint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PolygonFootprint.html">PolygonFootprint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that approximates the robot/human with a closed polygon.  <a href="classhateb__local__planner_1_1PolygonFootprint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1BaseTebUnaryEdge.html">BaseTebUnaryEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base edge connecting a single vertex in the TEB optimization problem.  <a href="classhateb__local__planner_1_1BaseTebUnaryEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1BaseTebBinaryEdge.html">BaseTebBinaryEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base edge connecting two vertices in the TEB optimization problem.  <a href="classhateb__local__planner_1_1BaseTebBinaryEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1BaseTebMultiEdge.html">BaseTebMultiEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base edge connecting multiple vertices in the TEB optimization problem.  <a href="classhateb__local__planner_1_1BaseTebMultiEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAcceleration.html">EdgeAcceleration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational acceleration.  <a href="classhateb__local__planner_1_1EdgeAcceleration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAccelerationStart.html">EdgeAccelerationStart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational acceleration at the beginning of the trajectory.  <a href="classhateb__local__planner_1_1EdgeAccelerationStart.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAccelerationGoal.html">EdgeAccelerationGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational acceleration at the end of the trajectory.  <a href="classhateb__local__planner_1_1EdgeAccelerationGoal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAccelerationHolonomic.html">EdgeAccelerationHolonomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational acceleration.  <a href="classhateb__local__planner_1_1EdgeAccelerationHolonomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAccelerationHolonomicStart.html">EdgeAccelerationHolonomicStart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational acceleration at the beginning of the trajectory.  <a href="classhateb__local__planner_1_1EdgeAccelerationHolonomicStart.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAccelerationHolonomicGoal.html">EdgeAccelerationHolonomicGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational acceleration at the end of the trajectory.  <a href="classhateb__local__planner_1_1EdgeAccelerationHolonomicGoal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAgentAgentSafety.html">EdgeAgentAgentSafety</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining a safety constraint between two agent poses (e.g., humans) in the optimization graph.  <a href="classhateb__local__planner_1_1EdgeAgentAgentSafety.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAgentRobotRelVelocity.html">EdgeAgentRobotRelVelocity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining a relative velocity constraint between robot and agent trajectories in the optimization graph.  <a href="classhateb__local__planner_1_1EdgeAgentRobotRelVelocity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAgentRobotSafety.html">EdgeAgentRobotSafety</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining a safety constraint between a robot and an agent (e.g., human) in the optimization graph.  <a href="classhateb__local__planner_1_1EdgeAgentRobotSafety.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeAgentRobotVisibility.html">EdgeAgentRobotVisibility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining a visibility constraint between an agent and the robot in the optimization graph.  <a href="classhateb__local__planner_1_1EdgeAgentRobotVisibility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeDynamicObstacle.html">EdgeDynamicObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for keeping a distance from dynamic (moving) obstacles.  <a href="classhateb__local__planner_1_1EdgeDynamicObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeInvisibleHuman.html">EdgeInvisibleHuman</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining a constraint for invisible human agents in the optimization graph.  <a href="classhateb__local__planner_1_1EdgeInvisibleHuman.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeKinematicsDiffDrive.html">EdgeKinematicsDiffDrive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for satisfying the non-holonomic kinematics of a differential drive mobile robot.  <a href="classhateb__local__planner_1_1EdgeKinematicsDiffDrive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeKinematicsCarlike.html">EdgeKinematicsCarlike</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for satisfying the non-holonomic kinematics of a carlike mobile robot.  <a href="classhateb__local__planner_1_1EdgeKinematicsCarlike.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeObstacle.html">EdgeObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for keeping a minimum distance from obstacles.  <a href="classhateb__local__planner_1_1EdgeObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeInflatedObstacle.html">EdgeInflatedObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for keeping a minimum distance from inflated obstacles.  <a href="classhateb__local__planner_1_1EdgeInflatedObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgePreferRotDir.html">EdgePreferRotDir</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for penalzing a specified turning direction, in particular left resp. right turns.  <a href="classhateb__local__planner_1_1EdgePreferRotDir.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeShortestPath.html">EdgeShortestPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for minimizing the Euclidean distance between two consectuive poses.  <a href="classhateb__local__planner_1_1EdgeShortestPath.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeStaticAgentVisibility.html">EdgeStaticAgentVisibility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining a visibility constraint between a static agent and the robot in the optimization graph.  <a href="classhateb__local__planner_1_1EdgeStaticAgentVisibility.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeTimeOptimal.html">EdgeTimeOptimal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for minimizing transition time of the trajectory.  <a href="classhateb__local__planner_1_1EdgeTimeOptimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeVelocity.html">EdgeVelocity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational velocity.  <a href="classhateb__local__planner_1_1EdgeVelocity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeVelocityHolonomic.html">EdgeVelocityHolonomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for limiting the translational and rotational velocity according to x,y and theta.  <a href="classhateb__local__planner_1_1EdgeVelocityHolonomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeVelocityHolonomicAgent.html">EdgeVelocityHolonomicAgent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeVelocityAgent.html">EdgeVelocityAgent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1EdgeViaPoint.html">EdgeViaPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edge defining the cost function for pushing a configuration towards a via point.  <a href="classhateb__local__planner_1_1EdgeViaPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1VertexPose.html">VertexPose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class stores and wraps a SE2 pose (position and orientation) into a vertex that can be optimized via g2o.  <a href="classhateb__local__planner_1_1VertexPose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1VertexTimeDiff.html">VertexTimeDiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class stores and wraps a time difference <img class="formulaInl" alt="$ \Delta T $" src="form_26.png"/> into a vertex that can be optimized via g2o.  <a href="classhateb__local__planner_1_1VertexTimeDiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1HATebConfig.html">HATebConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Config class for the <a class="el" href="namespacehateb__local__planner.html">hateb_local_planner</a> and its components.  <a href="classhateb__local__planner_1_1HATebConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1HATebLocalPlannerROS.html">HATebLocalPlannerROS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements both nav_core::BaseLocalPlanner and mbf_costmap_core::CostmapController abstract interfaces, so the <a class="el" href="namespacehateb__local__planner.html">hateb_local_planner</a> plugin can be used both in move_base and move_base_flex (MBF).  <a href="classhateb__local__planner_1_1HATebLocalPlannerROS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1ModeSwitch.html">ModeSwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class managing planning mode switches in the HATEB local planner.  <a href="classhateb__local__planner_1_1ModeSwitch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1Obstacle.html">Obstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines the interface for modelling obstacles.  <a href="classhateb__local__planner_1_1Obstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PointObstacle.html">PointObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a 2D point obstacle.  <a href="classhateb__local__planner_1_1PointObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1CircularObstacle.html">CircularObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a 2D circular obstacle (point obstacle plus radius)  <a href="classhateb__local__planner_1_1CircularObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1LineObstacle.html">LineObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a 2D line obstacle.  <a href="classhateb__local__planner_1_1LineObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PolygonObstacle.html">PolygonObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a polygon obstacle with an arbitrary number of vertices.  <a href="classhateb__local__planner_1_1PolygonObstacle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html">TebOptimalPlanner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class optimizes an internal Timed Elastic Band trajectory using the g2o-framework.  <a href="classhateb__local__planner_1_1TebOptimalPlanner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PlannerInterface.html">PlannerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class defines an interface for local planners.  <a href="classhateb__local__planner_1_1PlannerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1PoseSE2.html">PoseSE2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pose in the domain SE2: <img class="formulaInl" alt="$ \mathbb{R}^2 \times S^1 $" src="form_33.png"/> The pose consist of the position x and y and an orientation given as angle theta [-pi, pi].  <a href="classhateb__local__planner_1_1PoseSE2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1FailureDetector.html">FailureDetector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements methods in order to detect if the robot got stucked or is oscillating.  <a href="classhateb__local__planner_1_1FailureDetector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1TimedElasticBand.html">TimedElasticBand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that defines a trajectory modeled as an elastic band with augmented tempoarl information.  <a href="classhateb__local__planner_1_1TimedElasticBand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhateb__local__planner_1_1PlanTrajCombined.html">PlanTrajCombined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhateb__local__planner_1_1PlanCombined.html">PlanCombined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhateb__local__planner_1_1AgentPlanTrajCombined.html">AgentPlanTrajCombined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhateb__local__planner_1_1AgentPlanCombined.html">AgentPlanCombined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhateb__local__planner_1_1TebVisualization.html">TebVisualization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward Declaration.  <a href="classhateb__local__planner_1_1TebVisualization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aada6c9abcaa246f092095786ca9bf598"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> = std::vector&lt; Eigen::Vector2d, Eigen::aligned_allocator&lt; Eigen::Vector2d &gt; &gt;</td></tr>
<tr class="memdesc:aada6c9abcaa246f092095786ca9bf598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for a container storing 2d points.  <a href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">More...</a><br /></td></tr>
<tr class="separator:aada6c9abcaa246f092095786ca9bf598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb633f39a551ef9e0a25c9e1134ae491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#acb633f39a551ef9e0a25c9e1134ae491">FootprintModelPtr</a> = boost::shared_ptr&lt; <a class="el" href="classhateb__local__planner_1_1BaseFootprintModel.html">BaseFootprintModel</a> &gt;</td></tr>
<tr class="memdesc:acb633f39a551ef9e0a25c9e1134ae491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared obstacle pointers.  <a href="namespacehateb__local__planner.html#acb633f39a551ef9e0a25c9e1134ae491">More...</a><br /></td></tr>
<tr class="separator:acb633f39a551ef9e0a25c9e1134ae491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d8ed0e53dff57b1e62bc801c0cd3ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#af2d8ed0e53dff57b1e62bc801c0cd3ad">FootprintModelConstPtr</a> = boost::shared_ptr&lt; const <a class="el" href="classhateb__local__planner_1_1BaseFootprintModel.html">BaseFootprintModel</a> &gt;</td></tr>
<tr class="memdesc:af2d8ed0e53dff57b1e62bc801c0cd3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared obstacle const pointers.  <a href="namespacehateb__local__planner.html#af2d8ed0e53dff57b1e62bc801c0cd3ad">More...</a><br /></td></tr>
<tr class="separator:af2d8ed0e53dff57b1e62bc801c0cd3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f5d84de31cd8eeeffbbf5341bac099"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a96f5d84de31cd8eeeffbbf5341bac099">CircularFootprintPtr</a> = boost::shared_ptr&lt; <a class="el" href="classhateb__local__planner_1_1CircularFootprint.html">CircularFootprint</a> &gt;</td></tr>
<tr class="separator:a96f5d84de31cd8eeeffbbf5341bac099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5674a2ba3b2b0bd64cdd76db2fc7e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a6a5674a2ba3b2b0bd64cdd76db2fc7e3">ObstaclePtr</a> = boost::shared_ptr&lt; <a class="el" href="classhateb__local__planner_1_1Obstacle.html">Obstacle</a> &gt;</td></tr>
<tr class="memdesc:a6a5674a2ba3b2b0bd64cdd76db2fc7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared obstacle pointers.  <a href="namespacehateb__local__planner.html#a6a5674a2ba3b2b0bd64cdd76db2fc7e3">More...</a><br /></td></tr>
<tr class="separator:a6a5674a2ba3b2b0bd64cdd76db2fc7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e41a52836ef0622157f60b3515bfaa8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a4e41a52836ef0622157f60b3515bfaa8">ObstacleConstPtr</a> = boost::shared_ptr&lt; const <a class="el" href="classhateb__local__planner_1_1Obstacle.html">Obstacle</a> &gt;</td></tr>
<tr class="memdesc:a4e41a52836ef0622157f60b3515bfaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared obstacle const pointers.  <a href="namespacehateb__local__planner.html#a4e41a52836ef0622157f60b3515bfaa8">More...</a><br /></td></tr>
<tr class="separator:a4e41a52836ef0622157f60b3515bfaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fd52c70b6b2295dc138647919ea794"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#aa2fd52c70b6b2295dc138647919ea794">ObstContainer</a> = std::vector&lt; <a class="el" href="namespacehateb__local__planner.html#a6a5674a2ba3b2b0bd64cdd76db2fc7e3">ObstaclePtr</a> &gt;</td></tr>
<tr class="memdesc:aa2fd52c70b6b2295dc138647919ea794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for containers storing multiple obstacles.  <a href="namespacehateb__local__planner.html#aa2fd52c70b6b2295dc138647919ea794">More...</a><br /></td></tr>
<tr class="separator:aa2fd52c70b6b2295dc138647919ea794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87928ff56147a2fd4f1a7286b6e4ec17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a87928ff56147a2fd4f1a7286b6e4ec17">TEBBlockSolver</a> = g2o::BlockSolver&lt; g2o::BlockSolverTraits&lt;-1, -1 &gt; &gt;</td></tr>
<tr class="memdesc:a87928ff56147a2fd4f1a7286b6e4ec17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the block solver utilized for optimization.  <a href="namespacehateb__local__planner.html#a87928ff56147a2fd4f1a7286b6e4ec17">More...</a><br /></td></tr>
<tr class="separator:a87928ff56147a2fd4f1a7286b6e4ec17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedc27ee6fa1ed5261dd345d9026ecd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#acedc27ee6fa1ed5261dd345d9026ecd5">TEBLinearSolver</a> = g2o::LinearSolverCholmod&lt; TEBBlockSolver::PoseMatrixType &gt;</td></tr>
<tr class="memdesc:acedc27ee6fa1ed5261dd345d9026ecd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the linear solver utilized for optimization.  <a href="namespacehateb__local__planner.html#acedc27ee6fa1ed5261dd345d9026ecd5">More...</a><br /></td></tr>
<tr class="separator:acedc27ee6fa1ed5261dd345d9026ecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1464081de429166488fe52d38f977c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#aa1464081de429166488fe52d38f977c6">ViaPointContainer</a> = std::vector&lt; Eigen::Vector2d, Eigen::aligned_allocator&lt; Eigen::Vector2d &gt; &gt;</td></tr>
<tr class="memdesc:aa1464081de429166488fe52d38f977c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a container storing via-points.  <a href="namespacehateb__local__planner.html#aa1464081de429166488fe52d38f977c6">More...</a><br /></td></tr>
<tr class="separator:aa1464081de429166488fe52d38f977c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc15745e3b35b02461a967b832dcc7ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#afc15745e3b35b02461a967b832dcc7ed">TebOptimalPlannerPtr</a> = boost::shared_ptr&lt; <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html">TebOptimalPlanner</a> &gt;</td></tr>
<tr class="memdesc:afc15745e3b35b02461a967b832dcc7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared instances of the <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html" title="This class optimizes an internal Timed Elastic Band trajectory using the g2o-framework.">TebOptimalPlanner</a>.  <a href="namespacehateb__local__planner.html#afc15745e3b35b02461a967b832dcc7ed">More...</a><br /></td></tr>
<tr class="separator:afc15745e3b35b02461a967b832dcc7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4679377680be2798964279774edd095"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ae4679377680be2798964279774edd095">TebOptimalPlannerConstPtr</a> = boost::shared_ptr&lt; const <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html">TebOptimalPlanner</a> &gt;</td></tr>
<tr class="memdesc:ae4679377680be2798964279774edd095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared const <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html" title="This class optimizes an internal Timed Elastic Band trajectory using the g2o-framework.">TebOptimalPlanner</a> pointers.  <a href="namespacehateb__local__planner.html#ae4679377680be2798964279774edd095">More...</a><br /></td></tr>
<tr class="separator:ae4679377680be2798964279774edd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab4e8f2d06fd4a9d51fa1d7dccdf60b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#acab4e8f2d06fd4a9d51fa1d7dccdf60b">TebOptPlannerContainer</a> = std::vector&lt; <a class="el" href="namespacehateb__local__planner.html#afc15745e3b35b02461a967b832dcc7ed">TebOptimalPlannerPtr</a> &gt;</td></tr>
<tr class="memdesc:acab4e8f2d06fd4a9d51fa1d7dccdf60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for containers storing multiple teb optimal planners.  <a href="namespacehateb__local__planner.html#acab4e8f2d06fd4a9d51fa1d7dccdf60b">More...</a><br /></td></tr>
<tr class="separator:acab4e8f2d06fd4a9d51fa1d7dccdf60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d05bda75770b4a63ec4c1d940372e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a88d05bda75770b4a63ec4c1d940372e8">PlanStartVelGoalVel</a> = struct { std::vector&lt; geometry_msgs::PoseStamped &gt; plan</td></tr>
<tr class="separator:a88d05bda75770b4a63ec4c1d940372e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4752a48696bcc63570d62786fb9736"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a3b4752a48696bcc63570d62786fb9736">AgentPlanVelMap</a> = std::map&lt; uint64_t, <a class="el" href="namespacehateb__local__planner.html#a88d05bda75770b4a63ec4c1d940372e8">PlanStartVelGoalVel</a> &gt;</td></tr>
<tr class="separator:a3b4752a48696bcc63570d62786fb9736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4119254a399f35d2c880803d7ec93b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ae4119254a399f35d2c880803d7ec93b2">PlannerInterfacePtr</a> = boost::shared_ptr&lt; <a class="el" href="classhateb__local__planner_1_1PlannerInterface.html">PlannerInterface</a> &gt;</td></tr>
<tr class="memdesc:ae4119254a399f35d2c880803d7ec93b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared instances of <a class="el" href="classhateb__local__planner_1_1PlannerInterface.html" title="This abstract class defines an interface for local planners.">PlannerInterface</a> or it's subclasses.  <a href="namespacehateb__local__planner.html#ae4119254a399f35d2c880803d7ec93b2">More...</a><br /></td></tr>
<tr class="separator:ae4119254a399f35d2c880803d7ec93b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0456022df4079e7f827f10ee64981a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#adb0456022df4079e7f827f10ee64981a">PoseSequence</a> = std::vector&lt; <a class="el" href="classhateb__local__planner_1_1VertexPose.html">VertexPose</a> * &gt;</td></tr>
<tr class="memdesc:adb0456022df4079e7f827f10ee64981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of poses that represent the spatial part of the trajectory.  <a href="namespacehateb__local__planner.html#adb0456022df4079e7f827f10ee64981a">More...</a><br /></td></tr>
<tr class="separator:adb0456022df4079e7f827f10ee64981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee10d61c614b0238212192794ba76a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a6ee10d61c614b0238212192794ba76a2">TimeDiffSequence</a> = std::vector&lt; <a class="el" href="classhateb__local__planner_1_1VertexTimeDiff.html">VertexTimeDiff</a> * &gt;</td></tr>
<tr class="memdesc:a6ee10d61c614b0238212192794ba76a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of time differences that define the temporal of the trajectory.  <a href="namespacehateb__local__planner.html#a6ee10d61c614b0238212192794ba76a2">More...</a><br /></td></tr>
<tr class="separator:a6ee10d61c614b0238212192794ba76a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189cd7a87216df6bcfef993ad267dd11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a189cd7a87216df6bcfef993ad267dd11">TebVisualizationPtr</a> = boost::shared_ptr&lt; <a class="el" href="classhateb__local__planner_1_1TebVisualization.html">TebVisualization</a> &gt;</td></tr>
<tr class="memdesc:a189cd7a87216df6bcfef993ad267dd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared instances of the <a class="el" href="classhateb__local__planner_1_1TebVisualization.html" title="Forward Declaration.">TebVisualization</a>.  <a href="namespacehateb__local__planner.html#a189cd7a87216df6bcfef993ad267dd11">More...</a><br /></td></tr>
<tr class="separator:a189cd7a87216df6bcfef993ad267dd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6179d40b775a55a6fa71681cda5e40c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a6179d40b775a55a6fa71681cda5e40c7">TebVisualizationConstPtr</a> = boost::shared_ptr&lt; const <a class="el" href="classhateb__local__planner_1_1TebVisualization.html">TebVisualization</a> &gt;</td></tr>
<tr class="memdesc:a6179d40b775a55a6fa71681cda5e40c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbrev. for shared instances of the <a class="el" href="classhateb__local__planner_1_1TebVisualization.html" title="Forward Declaration.">TebVisualization</a> (read-only)  <a href="namespacehateb__local__planner.html#a6179d40b775a55a6fa71681cda5e40c7">More...</a><br /></td></tr>
<tr class="separator:a6179d40b775a55a6fa71681cda5e40c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abf9d2429f0e193ae1b58a22309f8e7fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7fa">PLAN</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7faa920a55168971579d99b33ecbc5a8818d">SINGLE_BAND</a>
, <a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7faa2f42651e1382b441e241f275380248f8">DUAL_BAND</a>
, <a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7faaa6abe4839659313e448501949a814c22">VELOBS</a>
, <a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7faa0e7a6013dfd67753cefe0fbab4c82512">BACKOFF</a>
, <br />
&#160;&#160;<a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7faaf2b794399c666f8c8779e958d7fe6179">PASSTHROUGH</a>
<br />
 }</td></tr>
<tr class="memdesc:abf9d2429f0e193ae1b58a22309f8e7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Planning mode enumeration Defines different modes of operation for the local planner.  <a href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7fa">More...</a><br /></td></tr>
<tr class="separator:abf9d2429f0e193ae1b58a22309f8e7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9053a9eaf358ea63f7d8f3c651376a8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8a">PREDICTION</a> : std::uint8_t { <a class="el" href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8aae084372d0f97f6da8cf1b9ef9fc4b28b">CONST_VEL</a>
, <a class="el" href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8aa51415e167991087447c6a0bcaa8663c8">BEHIND</a>
, <a class="el" href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8aa24daee122289cc15d963dffa694e7566">PREDICT</a>
, <a class="el" href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8aad6a95a52fdca114b7923c4a52cc38f72">EXTERNAL</a>
 }</td></tr>
<tr class="memdesc:a9053a9eaf358ea63f7d8f3c651376a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prediction mode enumeration Defines different strategies for predicting human motion.  <a href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8a">More...</a><br /></td></tr>
<tr class="separator:a9053a9eaf358ea63f7d8f3c651376a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e48cf4ccfab9dcfc0344d64f6e0c503"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503">AgentState</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503a8eaf13f36ff537218a27449e4a36517e">NO_STATE</a>
, <a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503afe6f99ef1ec99efbdc19a9786cf1facc">STATIC</a>
, <a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503aaf5a690fd5ec6f789dbfc51ec6a891ba">MOVING</a>
, <a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503a09d4d696b4e935115b9313e3c412509a">STOPPED</a>
, <br />
&#160;&#160;<a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503aeecba0068950a2df17c47e851e1eef14">BLOCKED</a>
<br />
 }</td></tr>
<tr class="separator:a1e48cf4ccfab9dcfc0344d64f6e0c503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463aa878b6972598ee87204519a60ba0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a463aa878b6972598ee87204519a60ba0">RotType</a> : std::uint8_t { <a class="el" href="namespacehateb__local__planner.html#a463aa878b6972598ee87204519a60ba0a811882fecd5c7618d7099ebbd39ea254">left</a>
, <a class="el" href="namespacehateb__local__planner.html#a463aa878b6972598ee87204519a60ba0a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a>
, <a class="el" href="namespacehateb__local__planner.html#a463aa878b6972598ee87204519a60ba0a7c4f29407893c334a6cb7a87bf045c0d">right</a>
 }</td></tr>
<tr class="memdesc:a463aa878b6972598ee87204519a60ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbols for left/none/right rotations.  <a href="namespacehateb__local__planner.html#a463aa878b6972598ee87204519a60ba0">More...</a><br /></td></tr>
<tr class="separator:a463aa878b6972598ee87204519a60ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a634b06994a4ecb77b1f523162e152c36"><td class="memTemplParams" colspan="2">template&lt;class DerivedT &gt; </td></tr>
<tr class="memitem:a634b06994a4ecb77b1f523162e152c36"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a634b06994a4ecb77b1f523162e152c36">RegisterStatefulActionNodeROS</a> (BT::BehaviorTreeFactory &amp;factory, const std::string &amp;registration_ID, ros::NodeHandle &amp;node_handle)</td></tr>
<tr class="memdesc:a634b06994a4ecb77b1f523162e152c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a stateful action node with the behavior tree factory.  <a href="namespacehateb__local__planner.html#a634b06994a4ecb77b1f523162e152c36">More...</a><br /></td></tr>
<tr class="separator:a634b06994a4ecb77b1f523162e152c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af895105afa3bbde12cf912915473fcb1"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#af895105afa3bbde12cf912915473fcb1">closest_point_on_line_segment_2d</a> (const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;point, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line_start, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line_end)</td></tr>
<tr class="memdesc:af895105afa3bbde12cf912915473fcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain the closest point on a line segment w.r.t. a reference point.  <a href="namespacehateb__local__planner.html#af895105afa3bbde12cf912915473fcb1">More...</a><br /></td></tr>
<tr class="separator:af895105afa3bbde12cf912915473fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa76447cf46833d01b4dd5647ecfe86"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#adfa76447cf46833d01b4dd5647ecfe86">distance_point_to_segment_2d</a> (const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;point, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line_start, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line_end)</td></tr>
<tr class="memdesc:adfa76447cf46833d01b4dd5647ecfe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the distance between a line segment and a point.  <a href="namespacehateb__local__planner.html#adfa76447cf46833d01b4dd5647ecfe86">More...</a><br /></td></tr>
<tr class="separator:adfa76447cf46833d01b4dd5647ecfe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6390beb4d01c1661e1c7523f74a93b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#aa6390beb4d01c1661e1c7523f74a93b2">check_line_segments_intersection_2d</a> (const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line1_start, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line1_end, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line2_start, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line2_end, Eigen::Vector2d *intersection=NULL)</td></tr>
<tr class="memdesc:aa6390beb4d01c1661e1c7523f74a93b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check whether two line segments intersects.  <a href="namespacehateb__local__planner.html#aa6390beb4d01c1661e1c7523f74a93b2">More...</a><br /></td></tr>
<tr class="separator:aa6390beb4d01c1661e1c7523f74a93b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e2d2432c7bf42cd93079ae086f9b27"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ac2e2d2432c7bf42cd93079ae086f9b27">distance_segment_to_segment_2d</a> (const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line1_start, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line1_end, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line2_start, const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;line2_end)</td></tr>
<tr class="memdesc:ac2e2d2432c7bf42cd93079ae086f9b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the smallest distance between two line segments.  <a href="namespacehateb__local__planner.html#ac2e2d2432c7bf42cd93079ae086f9b27">More...</a><br /></td></tr>
<tr class="separator:ac2e2d2432c7bf42cd93079ae086f9b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb251a59ae7588035748ef6afd02519"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a3fb251a59ae7588035748ef6afd02519">distance_point_to_polygon_2d</a> (const Eigen::Vector2d &amp;point, const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;vertices)</td></tr>
<tr class="memdesc:a3fb251a59ae7588035748ef6afd02519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the smallest distance between a point and a closed polygon.  <a href="namespacehateb__local__planner.html#a3fb251a59ae7588035748ef6afd02519">More...</a><br /></td></tr>
<tr class="separator:a3fb251a59ae7588035748ef6afd02519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53d0dcfdd477c66b3ae14cad3100f1d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ae53d0dcfdd477c66b3ae14cad3100f1d">distance_segment_to_polygon_2d</a> (const Eigen::Vector2d &amp;line_start, const Eigen::Vector2d &amp;line_end, const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;vertices)</td></tr>
<tr class="memdesc:ae53d0dcfdd477c66b3ae14cad3100f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the smallest distance between a line segment and a closed polygon.  <a href="namespacehateb__local__planner.html#ae53d0dcfdd477c66b3ae14cad3100f1d">More...</a><br /></td></tr>
<tr class="separator:ae53d0dcfdd477c66b3ae14cad3100f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7390a4788c5cdca6fecac1aa7315958e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a7390a4788c5cdca6fecac1aa7315958e">distance_polygon_to_polygon_2d</a> (const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;vertices1, const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;vertices2)</td></tr>
<tr class="memdesc:a7390a4788c5cdca6fecac1aa7315958e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the smallest distance between two closed polygons.  <a href="namespacehateb__local__planner.html#a7390a4788c5cdca6fecac1aa7315958e">More...</a><br /></td></tr>
<tr class="separator:a7390a4788c5cdca6fecac1aa7315958e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc129d7b0acdd86b557bf37bbb0cd15"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#accc129d7b0acdd86b557bf37bbb0cd15">calc_distance_line_to_line_3d</a> (const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;x1, Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;u, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;x2, Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;v)</td></tr>
<tr class="separator:accc129d7b0acdd86b557bf37bbb0cd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad608f81b0ad730706ceece80d5dac429"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ad608f81b0ad730706ceece80d5dac429">calc_distance_segment_to_segment3D</a> (const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;line1_start, Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;line1_end, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;line2_start, Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;line2_end)</td></tr>
<tr class="separator:ad608f81b0ad730706ceece80d5dac429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c95517e3f1a8468a88f3db377831228"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a9c95517e3f1a8468a88f3db377831228"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a9c95517e3f1a8468a88f3db377831228">calc_closest_point_to_approach_time</a> (const VectorType &amp;x1, const VectorType &amp;vel1, const VectorType &amp;x2, const VectorType &amp;vel2)</td></tr>
<tr class="separator:a9c95517e3f1a8468a88f3db377831228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149078819e493c9816eb27d45420fb99"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a149078819e493c9816eb27d45420fb99"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a149078819e493c9816eb27d45420fb99">calc_closest_point_to_approach_distance</a> (const VectorType &amp;x1, const VectorType &amp;vel1, const VectorType &amp;x2, const VectorType &amp;vel2, double bound_cpa_time=0)</td></tr>
<tr class="separator:a149078819e493c9816eb27d45420fb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa85a1b4b27c909f8d43a422a63945b"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a0fa85a1b4b27c909f8d43a422a63945b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a0fa85a1b4b27c909f8d43a422a63945b">calc_distance_point_to_line</a> (const VectorType &amp;point, const VectorType &amp;line_base, const VectorType &amp;line_dir)</td></tr>
<tr class="separator:a0fa85a1b4b27c909f8d43a422a63945b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c118ac06a1f7d66fd756bfe4a8a7d1c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a0c118ac06a1f7d66fd756bfe4a8a7d1c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a0c118ac06a1f7d66fd756bfe4a8a7d1c">calc_distance_point_to_segment</a> (const VectorType &amp;point, const VectorType &amp;line_start, const VectorType &amp;line_end)</td></tr>
<tr class="separator:a0c118ac06a1f7d66fd756bfe4a8a7d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ada7ff1cf4c2ece889d82f15b01710"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a94ada7ff1cf4c2ece889d82f15b01710">penaltyBoundToInterval</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="memdesc:a94ada7ff1cf4c2ece889d82f15b01710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ -a &lt; var &lt; a $" src="form_21.png"/>.  <a href="namespacehateb__local__planner.html#a94ada7ff1cf4c2ece889d82f15b01710">More...</a><br /></td></tr>
<tr class="separator:a94ada7ff1cf4c2ece889d82f15b01710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb0ebd0746958b63ff8a9481d5686e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#affb0ebd0746958b63ff8a9481d5686e0">penaltyBoundToInterval</a> (const double &amp;var, const double &amp;a, const double &amp;b, const double &amp;epsilon)</td></tr>
<tr class="memdesc:affb0ebd0746958b63ff8a9481d5686e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ a &lt; var &lt; b $" src="form_22.png"/>.  <a href="namespacehateb__local__planner.html#affb0ebd0746958b63ff8a9481d5686e0">More...</a><br /></td></tr>
<tr class="separator:affb0ebd0746958b63ff8a9481d5686e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d8f17ad8f685bedc4aaf2ea24a47f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ab0d8f17ad8f685bedc4aaf2ea24a47f1">penaltyBoundFromBelow</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="memdesc:ab0d8f17ad8f685bedc4aaf2ea24a47f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear penalty function for bounding <code>var</code> from below: <img class="formulaInl" alt="$ a &lt; var $" src="form_23.png"/>.  <a href="namespacehateb__local__planner.html#ab0d8f17ad8f685bedc4aaf2ea24a47f1">More...</a><br /></td></tr>
<tr class="separator:ab0d8f17ad8f685bedc4aaf2ea24a47f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3f92de1df6ab7ba7cce0a3c30aa50"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ae7a3f92de1df6ab7ba7cce0a3c30aa50">penaltyBoundFromAbove</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="separator:ae7a3f92de1df6ab7ba7cce0a3c30aa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15250529ebfe9fe310c0e0dc62617472"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a15250529ebfe9fe310c0e0dc62617472">penaltyBoundToIntervalDerivative</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="memdesc:a15250529ebfe9fe310c0e0dc62617472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ -a &lt; var &lt; a $" src="form_21.png"/>.  <a href="namespacehateb__local__planner.html#a15250529ebfe9fe310c0e0dc62617472">More...</a><br /></td></tr>
<tr class="separator:a15250529ebfe9fe310c0e0dc62617472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe24da4ec2cf8d7e9e4d0ddc667200a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#aebe24da4ec2cf8d7e9e4d0ddc667200a">penaltyBoundToIntervalDerivative</a> (const double &amp;var, const double &amp;a, const double &amp;b, const double &amp;epsilon)</td></tr>
<tr class="memdesc:aebe24da4ec2cf8d7e9e4d0ddc667200a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ a &lt; var &lt; b $" src="form_22.png"/>.  <a href="namespacehateb__local__planner.html#aebe24da4ec2cf8d7e9e4d0ddc667200a">More...</a><br /></td></tr>
<tr class="separator:aebe24da4ec2cf8d7e9e4d0ddc667200a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bba69036c01261cfb3a0a0a4901ff5c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a0bba69036c01261cfb3a0a0a4901ff5c">penaltyBoundFromBelowDerivative</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="memdesc:a0bba69036c01261cfb3a0a0a4901ff5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the linear penalty function for bounding <code>var</code> from below: <img class="formulaInl" alt="$ a &lt; var $" src="form_23.png"/>.  <a href="namespacehateb__local__planner.html#a0bba69036c01261cfb3a0a0a4901ff5c">More...</a><br /></td></tr>
<tr class="separator:a0bba69036c01261cfb3a0a0a4901ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803bab130c6e16215b0ddd8cb03fb1a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a803bab130c6e16215b0ddd8cb03fb1a3">penaltyBoundFromBelowExp</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon, const double &amp;mul)</td></tr>
<tr class="separator:a803bab130c6e16215b0ddd8cb03fb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b6c3c0d8dc4e84e5059ecb0bfb57ed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#af2b6c3c0d8dc4e84e5059ecb0bfb57ed">penaltyBoundFromBelowNonLinear</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="separator:af2b6c3c0d8dc4e84e5059ecb0bfb57ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fc0ad9921b131015538d3d29ec4f75"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#ac0fc0ad9921b131015538d3d29ec4f75">penaltyBoundFromBelowQuad</a> (const double &amp;var, const double &amp;a, const double &amp;epsilon)</td></tr>
<tr class="separator:ac0fc0ad9921b131015538d3d29ec4f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae8764bdacddaee9b80a5866db3b9b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a2ae8764bdacddaee9b80a5866db3b9b8">is_close</a> (double a, double b, double epsilon=1e-4)</td></tr>
<tr class="memdesc:a2ae8764bdacddaee9b80a5866db3b9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two variables (double) are close to each other.  <a href="namespacehateb__local__planner.html#a2ae8764bdacddaee9b80a5866db3b9b8">More...</a><br /></td></tr>
<tr class="separator:a2ae8764bdacddaee9b80a5866db3b9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8ed497f13dd817219467f6851caf61"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a9d8ed497f13dd817219467f6851caf61">average_angles</a> (const std::vector&lt; double &gt; &amp;angles)</td></tr>
<tr class="memdesc:a9d8ed497f13dd817219467f6851caf61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average angle of an arbitrary number of given angles [rad].  <a href="namespacehateb__local__planner.html#a9d8ed497f13dd817219467f6851caf61">More...</a><br /></td></tr>
<tr class="separator:a9d8ed497f13dd817219467f6851caf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef51438998773bdbcaed0119e2a62a4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#aef51438998773bdbcaed0119e2a62a4b">smaller_than_abs</a> (double i, double j)</td></tr>
<tr class="memdesc:aef51438998773bdbcaed0119e2a62a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small helper function: check if |a|&lt;|b|.  <a href="namespacehateb__local__planner.html#aef51438998773bdbcaed0119e2a62a4b">More...</a><br /></td></tr>
<tr class="separator:aef51438998773bdbcaed0119e2a62a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39af8f619a3185d081cde50624f5dfa8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a39af8f619a3185d081cde50624f5dfa8">fast_sigmoid</a> (double x)</td></tr>
<tr class="memdesc:a39af8f619a3185d081cde50624f5dfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a fast approximation of a sigmoid function.  <a href="namespacehateb__local__planner.html#a39af8f619a3185d081cde50624f5dfa8">More...</a><br /></td></tr>
<tr class="separator:a39af8f619a3185d081cde50624f5dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d33026d8646b389f2a76addd252325"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#af0d33026d8646b389f2a76addd252325">center_radians</a> (double angle)</td></tr>
<tr class="separator:af0d33026d8646b389f2a76addd252325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b283a25ac83d84e4340dc2e25fa6f20"><td class="memTemplParams" colspan="2">template&lt;typename P1 , typename P2 &gt; </td></tr>
<tr class="memitem:a6b283a25ac83d84e4340dc2e25fa6f20"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a6b283a25ac83d84e4340dc2e25fa6f20">distance_points2d</a> (const P1 &amp;point1, const P2 &amp;point2)</td></tr>
<tr class="memdesc:a6b283a25ac83d84e4340dc2e25fa6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Euclidean distance between two 2D point datatypes.  <a href="namespacehateb__local__planner.html#a6b283a25ac83d84e4340dc2e25fa6f20">More...</a><br /></td></tr>
<tr class="separator:a6b283a25ac83d84e4340dc2e25fa6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d058c71c6324fe929db8d83d7fa43a"><td class="memTemplParams" colspan="2">template&lt;typename V1 , typename V2 &gt; </td></tr>
<tr class="memitem:a93d058c71c6324fe929db8d83d7fa43a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a93d058c71c6324fe929db8d83d7fa43a">cross2d</a> (const V1 &amp;v1, const V2 &amp;v2)</td></tr>
<tr class="memdesc:a93d058c71c6324fe929db8d83d7fa43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the 2d cross product (returns length of the resulting vector along the z-axis in 3d)  <a href="namespacehateb__local__planner.html#a93d058c71c6324fe929db8d83d7fa43a">More...</a><br /></td></tr>
<tr class="separator:a93d058c71c6324fe929db8d83d7fa43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2109332af478b073ef8713bd5c8d3710"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2109332af478b073ef8713bd5c8d3710"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a2109332af478b073ef8713bd5c8d3710">get_const_reference</a> (const T *ptr)</td></tr>
<tr class="memdesc:a2109332af478b073ef8713bd5c8d3710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that returns the const reference to a value defined by either its raw pointer type or const reference.  <a href="namespacehateb__local__planner.html#a2109332af478b073ef8713bd5c8d3710">More...</a><br /></td></tr>
<tr class="separator:a2109332af478b073ef8713bd5c8d3710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f616f565ae6d41403359464581ddaaa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f616f565ae6d41403359464581ddaaa"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a5f616f565ae6d41403359464581ddaaa">get_const_reference</a> (const T &amp;val, typename boost::disable_if&lt; boost::is_pointer&lt; T &gt; &gt;::type *dummy=0)</td></tr>
<tr class="memdesc:a5f616f565ae6d41403359464581ddaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that returns the const reference to a value defined by either its raw pointer type or const reference.  <a href="namespacehateb__local__planner.html#a5f616f565ae6d41403359464581ddaaa">More...</a><br /></td></tr>
<tr class="separator:a5f616f565ae6d41403359464581ddaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a44e9e507bb08b55ba047f7edcf443643"><td class="memItemLeft" align="right" valign="top">geometry_msgs::Twist&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a44e9e507bb08b55ba047f7edcf443643">start_vel</a></td></tr>
<tr class="separator:a44e9e507bb08b55ba047f7edcf443643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ec0b46ee5b97db6df35361841f5bd2"><td class="memItemLeft" align="right" valign="top">geometry_msgs::Twist&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a35ec0b46ee5b97db6df35361841f5bd2">goal_vel</a></td></tr>
<tr class="separator:a35ec0b46ee5b97db6df35361841f5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646388b7d2c05dbfb029b1b00fd67f23"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a646388b7d2c05dbfb029b1b00fd67f23">nominal_vel</a></td></tr>
<tr class="separator:a646388b7d2c05dbfb029b1b00fd67f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be0980eee84fa548e6076bbca9a404c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehateb__local__planner.html#a8be0980eee84fa548e6076bbca9a404c">isMode</a></td></tr>
<tr class="separator:a8be0980eee84fa548e6076bbca9a404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3b4752a48696bcc63570d62786fb9736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4752a48696bcc63570d62786fb9736">&#9670;&nbsp;</a></span>AgentPlanVelMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a3b4752a48696bcc63570d62786fb9736">hateb_local_planner::AgentPlanVelMap</a> = typedef std::map&lt;uint64_t, <a class="el" href="namespacehateb__local__planner.html#a88d05bda75770b4a63ec4c1d940372e8">PlanStartVelGoalVel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96f5d84de31cd8eeeffbbf5341bac099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f5d84de31cd8eeeffbbf5341bac099">&#9670;&nbsp;</a></span>CircularFootprintPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a96f5d84de31cd8eeeffbbf5341bac099">hateb_local_planner::CircularFootprintPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classhateb__local__planner_1_1CircularFootprint.html">CircularFootprint</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2d8ed0e53dff57b1e62bc801c0cd3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d8ed0e53dff57b1e62bc801c0cd3ad">&#9670;&nbsp;</a></span>FootprintModelConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#af2d8ed0e53dff57b1e62bc801c0cd3ad">hateb_local_planner::FootprintModelConstPtr</a> = typedef boost::shared_ptr&lt;const <a class="el" href="classhateb__local__planner_1_1BaseFootprintModel.html">BaseFootprintModel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared obstacle const pointers. </p>

</div>
</div>
<a id="acb633f39a551ef9e0a25c9e1134ae491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb633f39a551ef9e0a25c9e1134ae491">&#9670;&nbsp;</a></span>FootprintModelPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#acb633f39a551ef9e0a25c9e1134ae491">hateb_local_planner::FootprintModelPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classhateb__local__planner_1_1BaseFootprintModel.html">BaseFootprintModel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared obstacle pointers. </p>

</div>
</div>
<a id="a4e41a52836ef0622157f60b3515bfaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e41a52836ef0622157f60b3515bfaa8">&#9670;&nbsp;</a></span>ObstacleConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a4e41a52836ef0622157f60b3515bfaa8">hateb_local_planner::ObstacleConstPtr</a> = typedef boost::shared_ptr&lt;const <a class="el" href="classhateb__local__planner_1_1Obstacle.html">Obstacle</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared obstacle const pointers. </p>

</div>
</div>
<a id="a6a5674a2ba3b2b0bd64cdd76db2fc7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5674a2ba3b2b0bd64cdd76db2fc7e3">&#9670;&nbsp;</a></span>ObstaclePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a6a5674a2ba3b2b0bd64cdd76db2fc7e3">hateb_local_planner::ObstaclePtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classhateb__local__planner_1_1Obstacle.html">Obstacle</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared obstacle pointers. </p>

</div>
</div>
<a id="aa2fd52c70b6b2295dc138647919ea794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fd52c70b6b2295dc138647919ea794">&#9670;&nbsp;</a></span>ObstContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#aa2fd52c70b6b2295dc138647919ea794">hateb_local_planner::ObstContainer</a> = typedef std::vector&lt;<a class="el" href="namespacehateb__local__planner.html#a6a5674a2ba3b2b0bd64cdd76db2fc7e3">ObstaclePtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for containers storing multiple obstacles. </p>

</div>
</div>
<a id="ae4119254a399f35d2c880803d7ec93b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4119254a399f35d2c880803d7ec93b2">&#9670;&nbsp;</a></span>PlannerInterfacePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#ae4119254a399f35d2c880803d7ec93b2">hateb_local_planner::PlannerInterfacePtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classhateb__local__planner_1_1PlannerInterface.html">PlannerInterface</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared instances of <a class="el" href="classhateb__local__planner_1_1PlannerInterface.html" title="This abstract class defines an interface for local planners.">PlannerInterface</a> or it's subclasses. </p>

</div>
</div>
<a id="a88d05bda75770b4a63ec4c1d940372e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d05bda75770b4a63ec4c1d940372e8">&#9670;&nbsp;</a></span>PlanStartVelGoalVel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a88d05bda75770b4a63ec4c1d940372e8">hateb_local_planner::PlanStartVelGoalVel</a> = typedef struct { std::vector&lt;geometry_msgs::PoseStamped&gt; plan</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aada6c9abcaa246f092095786ca9bf598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada6c9abcaa246f092095786ca9bf598">&#9670;&nbsp;</a></span>Point2dContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">hateb_local_planner::Point2dContainer</a> = typedef std::vector&lt;Eigen::Vector2d, Eigen::aligned_allocator&lt;Eigen::Vector2d&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for a container storing 2d points. </p>

</div>
</div>
<a id="adb0456022df4079e7f827f10ee64981a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0456022df4079e7f827f10ee64981a">&#9670;&nbsp;</a></span>PoseSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#adb0456022df4079e7f827f10ee64981a">hateb_local_planner::PoseSequence</a> = typedef std::vector&lt;<a class="el" href="classhateb__local__planner_1_1VertexPose.html">VertexPose</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container of poses that represent the spatial part of the trajectory. </p>

</div>
</div>
<a id="a87928ff56147a2fd4f1a7286b6e4ec17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87928ff56147a2fd4f1a7286b6e4ec17">&#9670;&nbsp;</a></span>TEBBlockSolver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a87928ff56147a2fd4f1a7286b6e4ec17">hateb_local_planner::TEBBlockSolver</a> = typedef g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;-1, -1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the block solver utilized for optimization. </p>

</div>
</div>
<a id="acedc27ee6fa1ed5261dd345d9026ecd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedc27ee6fa1ed5261dd345d9026ecd5">&#9670;&nbsp;</a></span>TEBLinearSolver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#acedc27ee6fa1ed5261dd345d9026ecd5">hateb_local_planner::TEBLinearSolver</a> = typedef g2o::LinearSolverCholmod&lt;TEBBlockSolver::PoseMatrixType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the linear solver utilized for optimization. </p>

</div>
</div>
<a id="ae4679377680be2798964279774edd095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4679377680be2798964279774edd095">&#9670;&nbsp;</a></span>TebOptimalPlannerConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#ae4679377680be2798964279774edd095">hateb_local_planner::TebOptimalPlannerConstPtr</a> = typedef boost::shared_ptr&lt;const <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html">TebOptimalPlanner</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared const <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html" title="This class optimizes an internal Timed Elastic Band trajectory using the g2o-framework.">TebOptimalPlanner</a> pointers. </p>

</div>
</div>
<a id="afc15745e3b35b02461a967b832dcc7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc15745e3b35b02461a967b832dcc7ed">&#9670;&nbsp;</a></span>TebOptimalPlannerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#afc15745e3b35b02461a967b832dcc7ed">hateb_local_planner::TebOptimalPlannerPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html">TebOptimalPlanner</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared instances of the <a class="el" href="classhateb__local__planner_1_1TebOptimalPlanner.html" title="This class optimizes an internal Timed Elastic Band trajectory using the g2o-framework.">TebOptimalPlanner</a>. </p>

</div>
</div>
<a id="acab4e8f2d06fd4a9d51fa1d7dccdf60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab4e8f2d06fd4a9d51fa1d7dccdf60b">&#9670;&nbsp;</a></span>TebOptPlannerContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#acab4e8f2d06fd4a9d51fa1d7dccdf60b">hateb_local_planner::TebOptPlannerContainer</a> = typedef std::vector&lt;<a class="el" href="namespacehateb__local__planner.html#afc15745e3b35b02461a967b832dcc7ed">TebOptimalPlannerPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for containers storing multiple teb optimal planners. </p>

</div>
</div>
<a id="a6179d40b775a55a6fa71681cda5e40c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6179d40b775a55a6fa71681cda5e40c7">&#9670;&nbsp;</a></span>TebVisualizationConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a6179d40b775a55a6fa71681cda5e40c7">hateb_local_planner::TebVisualizationConstPtr</a> = typedef boost::shared_ptr&lt;const <a class="el" href="classhateb__local__planner_1_1TebVisualization.html">TebVisualization</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared instances of the <a class="el" href="classhateb__local__planner_1_1TebVisualization.html" title="Forward Declaration.">TebVisualization</a> (read-only) </p>

</div>
</div>
<a id="a189cd7a87216df6bcfef993ad267dd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189cd7a87216df6bcfef993ad267dd11">&#9670;&nbsp;</a></span>TebVisualizationPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a189cd7a87216df6bcfef993ad267dd11">hateb_local_planner::TebVisualizationPtr</a> = typedef boost::shared_ptr&lt;<a class="el" href="classhateb__local__planner_1_1TebVisualization.html">TebVisualization</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abbrev. for shared instances of the <a class="el" href="classhateb__local__planner_1_1TebVisualization.html" title="Forward Declaration.">TebVisualization</a>. </p>

</div>
</div>
<a id="a6ee10d61c614b0238212192794ba76a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee10d61c614b0238212192794ba76a2">&#9670;&nbsp;</a></span>TimeDiffSequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#a6ee10d61c614b0238212192794ba76a2">hateb_local_planner::TimeDiffSequence</a> = typedef std::vector&lt;<a class="el" href="classhateb__local__planner_1_1VertexTimeDiff.html">VertexTimeDiff</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Container of time differences that define the temporal of the trajectory. </p>

</div>
</div>
<a id="aa1464081de429166488fe52d38f977c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1464081de429166488fe52d38f977c6">&#9670;&nbsp;</a></span>ViaPointContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehateb__local__planner.html#aa1464081de429166488fe52d38f977c6">hateb_local_planner::ViaPointContainer</a> = typedef std::vector&lt;Eigen::Vector2d, Eigen::aligned_allocator&lt;Eigen::Vector2d&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a container storing via-points. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1e48cf4ccfab9dcfc0344d64f6e0c503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e48cf4ccfab9dcfc0344d64f6e0c503">&#9670;&nbsp;</a></span>AgentState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehateb__local__planner.html#a1e48cf4ccfab9dcfc0344d64f6e0c503">hateb_local_planner::AgentState</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1e48cf4ccfab9dcfc0344d64f6e0c503a8eaf13f36ff537218a27449e4a36517e"></a>NO_STATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e48cf4ccfab9dcfc0344d64f6e0c503afe6f99ef1ec99efbdc19a9786cf1facc"></a>STATIC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e48cf4ccfab9dcfc0344d64f6e0c503aaf5a690fd5ec6f789dbfc51ec6a891ba"></a>MOVING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e48cf4ccfab9dcfc0344d64f6e0c503a09d4d696b4e935115b9313e3c412509a"></a>STOPPED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1e48cf4ccfab9dcfc0344d64f6e0c503aeecba0068950a2df17c47e851e1eef14"></a>BLOCKED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="abf9d2429f0e193ae1b58a22309f8e7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9d2429f0e193ae1b58a22309f8e7fa">&#9670;&nbsp;</a></span>PLAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehateb__local__planner.html#abf9d2429f0e193ae1b58a22309f8e7fa">hateb_local_planner::PLAN</a> : std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Planning mode enumeration Defines different modes of operation for the local planner. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abf9d2429f0e193ae1b58a22309f8e7faa920a55168971579d99b33ecbc5a8818d"></a>SINGLE_BAND&#160;</td><td class="fielddoc"><p>Single elastic band optimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="abf9d2429f0e193ae1b58a22309f8e7faa2f42651e1382b441e241f275380248f8"></a>DUAL_BAND&#160;</td><td class="fielddoc"><p>Dual elastic band optimization for robot and human. </p>
</td></tr>
<tr><td class="fieldname"><a id="abf9d2429f0e193ae1b58a22309f8e7faaa6abe4839659313e448501949a814c22"></a>VELOBS&#160;</td><td class="fielddoc"><p>Velocity obstacles-based planning. </p>
</td></tr>
<tr><td class="fieldname"><a id="abf9d2429f0e193ae1b58a22309f8e7faa0e7a6013dfd67753cefe0fbab4c82512"></a>BACKOFF&#160;</td><td class="fielddoc"><p><a class="el" href="classhateb__local__planner_1_1Backoff.html" title="Class implementing backoff behavior for robot navigation.">Backoff</a> behavior when stuck. </p>
</td></tr>
<tr><td class="fieldname"><a id="abf9d2429f0e193ae1b58a22309f8e7faaf2b794399c666f8c8779e958d7fe6179"></a>PASSTHROUGH&#160;</td><td class="fielddoc"><p>PassThrough Mode at passages. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9053a9eaf358ea63f7d8f3c651376a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9053a9eaf358ea63f7d8f3c651376a8a">&#9670;&nbsp;</a></span>PREDICTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehateb__local__planner.html#a9053a9eaf358ea63f7d8f3c651376a8a">hateb_local_planner::PREDICTION</a> : std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prediction mode enumeration Defines different strategies for predicting human motion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9053a9eaf358ea63f7d8f3c651376a8aae084372d0f97f6da8cf1b9ef9fc4b28b"></a>CONST_VEL&#160;</td><td class="fielddoc"><p>Constant velocity prediction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9053a9eaf358ea63f7d8f3c651376a8aa51415e167991087447c6a0bcaa8663c8"></a>BEHIND&#160;</td><td class="fielddoc"><p>Predicting the goal as behind the robot. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9053a9eaf358ea63f7d8f3c651376a8aa24daee122289cc15d963dffa694e7566"></a>PREDICT&#160;</td><td class="fielddoc"><p>Use internal goal prediction scheme. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9053a9eaf358ea63f7d8f3c651376a8aad6a95a52fdca114b7923c4a52cc38f72"></a>EXTERNAL&#160;</td><td class="fielddoc"><p>External prediction provided the human goals. </p>
</td></tr>
</table>

</div>
</div>
<a id="a463aa878b6972598ee87204519a60ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463aa878b6972598ee87204519a60ba0">&#9670;&nbsp;</a></span>RotType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehateb__local__planner.html#a463aa878b6972598ee87204519a60ba0">hateb_local_planner::RotType</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbols for left/none/right rotations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a463aa878b6972598ee87204519a60ba0a811882fecd5c7618d7099ebbd39ea254"></a>left&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a463aa878b6972598ee87204519a60ba0a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a463aa878b6972598ee87204519a60ba0a7c4f29407893c334a6cb7a87bf045c0d"></a>right&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9d8ed497f13dd817219467f6851caf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8ed497f13dd817219467f6851caf61">&#9670;&nbsp;</a></span>average_angles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::average_angles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>angles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the average angle of an arbitrary number of given angles [rad]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angles</td><td>vector containing all angles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>average / mean angle, that is normalized to [-pi, pi] </dd></dl>

</div>
</div>
<a id="a149078819e493c9816eb27d45420fb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149078819e493c9816eb27d45420fb99">&#9670;&nbsp;</a></span>calc_closest_point_to_approach_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::calc_closest_point_to_approach_distance </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vel1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vel2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bound_cpa_time</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c95517e3f1a8468a88f3db377831228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c95517e3f1a8468a88f3db377831228">&#9670;&nbsp;</a></span>calc_closest_point_to_approach_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::calc_closest_point_to_approach_time </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vel1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>vel2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accc129d7b0acdd86b557bf37bbb0cd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc129d7b0acdd86b557bf37bbb0cd15">&#9670;&nbsp;</a></span>calc_distance_line_to_line_3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::calc_distance_line_to_line_3d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fa85a1b4b27c909f8d43a422a63945b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa85a1b4b27c909f8d43a422a63945b">&#9670;&nbsp;</a></span>calc_distance_point_to_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::calc_distance_point_to_line </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>line_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>line_dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c118ac06a1f7d66fd756bfe4a8a7d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c118ac06a1f7d66fd756bfe4a8a7d1c">&#9670;&nbsp;</a></span>calc_distance_point_to_segment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::calc_distance_point_to_segment </td>
          <td>(</td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>line_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>line_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad608f81b0ad730706ceece80d5dac429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad608f81b0ad730706ceece80d5dac429">&#9670;&nbsp;</a></span>calc_distance_segment_to_segment3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::calc_distance_segment_to_segment3D </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line1_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line2_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line2_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0d33026d8646b389f2a76addd252325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d33026d8646b389f2a76addd252325">&#9670;&nbsp;</a></span>center_radians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::center_radians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6390beb4d01c1661e1c7523f74a93b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6390beb4d01c1661e1c7523f74a93b2">&#9670;&nbsp;</a></span>check_line_segments_intersection_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hateb_local_planner::check_line_segments_intersection_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line1_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line2_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line2_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector2d *&#160;</td>
          <td class="paramname"><em>intersection</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to check whether two line segments intersects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">line1_start</td><td>2D point representing the start of the first line segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line1_end</td><td>2D point representing the end of the first line segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line2_start</td><td>2D point representing the start of the second line segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line2_end</td><td>2D point representing the end of the second line segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersection</td><td>[optional] Write intersection point to destination (the value is only written, if both lines intersect, e.g. if the function returns <code>true</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both line segments intersect </dd></dl>

</div>
</div>
<a id="af895105afa3bbde12cf912915473fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af895105afa3bbde12cf912915473fcb1">&#9670;&nbsp;</a></span>closest_point_on_line_segment_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2d hateb_local_planner::closest_point_on_line_segment_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain the closest point on a line segment w.r.t. a reference point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>2D point </td></tr>
    <tr><td class="paramname">line_start</td><td>2D point representing the start of the line segment </td></tr>
    <tr><td class="paramname">line_end</td><td>2D point representing the end of the line segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Closest point on the line segment </dd></dl>

</div>
</div>
<a id="a93d058c71c6324fe929db8d83d7fa43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d058c71c6324fe929db8d83d7fa43a">&#9670;&nbsp;</a></span>cross2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V1 , typename V2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::cross2d </td>
          <td>(</td>
          <td class="paramtype">const V1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the 2d cross product (returns length of the resulting vector along the z-axis in 3d) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>object containing public methods x() and y() </td></tr>
    <tr><td class="paramname">v2</td><td>object containing fields x() and y() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>magnitude that would result in the 3D case (along the z-axis) </dd></dl>

</div>
</div>
<a id="a3fb251a59ae7588035748ef6afd02519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb251a59ae7588035748ef6afd02519">&#9670;&nbsp;</a></span>distance_point_to_polygon_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::distance_point_to_polygon_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to calculate the smallest distance between a point and a closed polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>2D point </td></tr>
    <tr><td class="paramname">vertices</td><td>Vertices describing the closed polygon (the first vertex is not repeated at the end) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest distance between point and polygon </dd></dl>

</div>
</div>
<a id="adfa76447cf46833d01b4dd5647ecfe86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa76447cf46833d01b4dd5647ecfe86">&#9670;&nbsp;</a></span>distance_point_to_segment_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::distance_point_to_segment_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to calculate the distance between a line segment and a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>2D point </td></tr>
    <tr><td class="paramname">line_start</td><td>2D point representing the start of the line segment </td></tr>
    <tr><td class="paramname">line_end</td><td>2D point representing the end of the line segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum distance to a given line segment </dd></dl>

</div>
</div>
<a id="a6b283a25ac83d84e4340dc2e25fa6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b283a25ac83d84e4340dc2e25fa6f20">&#9670;&nbsp;</a></span>distance_points2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P1 , typename P2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::distance_points2d </td>
          <td>(</td>
          <td class="paramtype">const P1 &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P2 &amp;&#160;</td>
          <td class="paramname"><em>point2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate Euclidean distance between two 2D point datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point1</td><td>object containing fields x and y </td></tr>
    <tr><td class="paramname">point2</td><td>object containing fields x and y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Euclidean distance: ||point2-point1|| </dd></dl>

</div>
</div>
<a id="a7390a4788c5cdca6fecac1aa7315958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7390a4788c5cdca6fecac1aa7315958e">&#9670;&nbsp;</a></span>distance_polygon_to_polygon_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::distance_polygon_to_polygon_2d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to calculate the smallest distance between two closed polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices1</td><td>Vertices describing the first closed polygon (the first vertex is not repeated at the end) </td></tr>
    <tr><td class="paramname">vertices2</td><td>Vertices describing the second closed polygon (the first vertex is not repeated at the end) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest distance between point and polygon </dd></dl>

</div>
</div>
<a id="ae53d0dcfdd477c66b3ae14cad3100f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53d0dcfdd477c66b3ae14cad3100f1d">&#9670;&nbsp;</a></span>distance_segment_to_polygon_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::distance_segment_to_polygon_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>line_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>line_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehateb__local__planner.html#aada6c9abcaa246f092095786ca9bf598">Point2dContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to calculate the smallest distance between a line segment and a closed polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line_start</td><td>2D point representing the start of the line segment </td></tr>
    <tr><td class="paramname">line_end</td><td>2D point representing the end of the line segment </td></tr>
    <tr><td class="paramname">vertices</td><td>Vertices describing the closed polygon (the first vertex is not repeated at the end) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest distance between point and polygon </dd></dl>

</div>
</div>
<a id="ac2e2d2432c7bf42cd93079ae086f9b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e2d2432c7bf42cd93079ae086f9b27">&#9670;&nbsp;</a></span>distance_segment_to_segment_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::distance_segment_to_segment_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line1_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line1_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line2_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector2d &gt; &amp;&#160;</td>
          <td class="paramname"><em>line2_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to calculate the smallest distance between two line segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line1_start</td><td>2D point representing the start of the first line segment </td></tr>
    <tr><td class="paramname">line1_end</td><td>2D point representing the end of the first line segment </td></tr>
    <tr><td class="paramname">line2_start</td><td>2D point representing the start of the second line segment </td></tr>
    <tr><td class="paramname">line2_end</td><td>2D point representing the end of the second line segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest distance between both segments </dd></dl>

</div>
</div>
<a id="a39af8f619a3185d081cde50624f5dfa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39af8f619a3185d081cde50624f5dfa8">&#9670;&nbsp;</a></span>fast_sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::fast_sigmoid </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a fast approximation of a sigmoid function. </p>
<p>The following function is implemented: <img class="formulaInl" alt="$ x / (1 + |x|) $" src="form_30.png"/> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the argument of the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f616f565ae6d41403359464581ddaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f616f565ae6d41403359464581ddaaa">&#9670;&nbsp;</a></span>get_const_reference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; hateb_local_planner::get_const_reference </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::disable_if&lt; boost::is_pointer&lt; T &gt; &gt;::type *&#160;</td>
          <td class="paramname"><em>dummy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that returns the const reference to a value defined by either its raw pointer type or const reference. </p>
<p>Return a constant reference for boths input variants (pointer or reference). </p><dl class="section remark"><dt>Remarks</dt><dd>Makes only sense in combination with the overload getConstReference(const T* val). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td></td></tr>
    <tr><td class="paramname">dummy</td><td>SFINAE helper variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>arbitrary type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>T</code> is a pointer, return const *T (leading to const T&amp;), otherwise const T&amp; with out pointer-to-ref conversion </dd></dl>

</div>
</div>
<a id="a2109332af478b073ef8713bd5c8d3710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2109332af478b073ef8713bd5c8d3710">&#9670;&nbsp;</a></span>get_const_reference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; hateb_local_planner::get_const_reference </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that returns the const reference to a value defined by either its raw pointer type or const reference. </p>
<p>Return a constant reference for boths input variants (pointer or reference). </p><dl class="section remark"><dt>Remarks</dt><dd>Makes only sense in combination with the overload getConstReference(const T&amp; val). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer of type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>arbitrary type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>T</code> is a pointer, return const *T (leading to const T&amp;), otherwise const T&amp; with out pointer-to-ref conversion </dd></dl>

</div>
</div>
<a id="a2ae8764bdacddaee9b80a5866db3b9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae8764bdacddaee9b80a5866db3b9b8">&#9670;&nbsp;</a></span>is_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hateb_local_planner::is_close </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two variables (double) are close to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first value to compare </td></tr>
    <tr><td class="paramname">b</td><td>the second value to compare </td></tr>
    <tr><td class="paramname">epsilon</td><td>precision threshold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if |a-b| &lt; epsilon, false otherwise </dd></dl>

</div>
</div>
<a id="ae7a3f92de1df6ab7ba7cce0a3c30aa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a3f92de1df6ab7ba7cce0a3c30aa50">&#9670;&nbsp;</a></span>penaltyBoundFromAbove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundFromAbove </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0d8f17ad8f685bedc4aaf2ea24a47f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d8f17ad8f685bedc4aaf2ea24a47f1">&#9670;&nbsp;</a></span>penaltyBoundFromBelow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundFromBelow </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear penalty function for bounding <code>var</code> from below: <img class="formulaInl" alt="$ a &lt; var $" src="form_23.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The scalar that should be bounded </td></tr>
    <tr><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramname">epsilon</td><td>safty margin (move bound to the interior of the interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehateb__local__planner.html#a0bba69036c01261cfb3a0a0a4901ff5c" title="Derivative of the linear penalty function for bounding var from below: .">penaltyBoundFromBelowDerivative</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Penalty / cost value that is nonzero if the constraint is not satisfied </dd></dl>

</div>
</div>
<a id="a0bba69036c01261cfb3a0a0a4901ff5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bba69036c01261cfb3a0a0a4901ff5c">&#9670;&nbsp;</a></span>penaltyBoundFromBelowDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundFromBelowDerivative </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative of the linear penalty function for bounding <code>var</code> from below: <img class="formulaInl" alt="$ a &lt; var $" src="form_23.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The scalar that should be bounded </td></tr>
    <tr><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramname">epsilon</td><td>safty margin (move bound to the interior of the interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehateb__local__planner.html#ab0d8f17ad8f685bedc4aaf2ea24a47f1" title="Linear penalty function for bounding var from below: .">penaltyBoundFromBelow</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of the penalty function w.r.t. <code>var</code> </dd></dl>

</div>
</div>
<a id="a803bab130c6e16215b0ddd8cb03fb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803bab130c6e16215b0ddd8cb03fb1a3">&#9670;&nbsp;</a></span>penaltyBoundFromBelowExp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundFromBelowExp </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>mul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2b6c3c0d8dc4e84e5059ecb0bfb57ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b6c3c0d8dc4e84e5059ecb0bfb57ed">&#9670;&nbsp;</a></span>penaltyBoundFromBelowNonLinear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundFromBelowNonLinear </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0fc0ad9921b131015538d3d29ec4f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fc0ad9921b131015538d3d29ec4f75">&#9670;&nbsp;</a></span>penaltyBoundFromBelowQuad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundFromBelowQuad </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="affb0ebd0746958b63ff8a9481d5686e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb0ebd0746958b63ff8a9481d5686e0">&#9670;&nbsp;</a></span>penaltyBoundToInterval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundToInterval </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ a &lt; var &lt; b $" src="form_22.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The scalar that should be bounded </td></tr>
    <tr><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramname">b</td><td>upper bound </td></tr>
    <tr><td class="paramname">epsilon</td><td>safty margin (move bound to the interior of the interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehateb__local__planner.html#a15250529ebfe9fe310c0e0dc62617472" title="Derivative of the linear penalty function for bounding var to the interval .">penaltyBoundToIntervalDerivative</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Penalty / cost value that is nonzero if the constraint is not satisfied </dd></dl>

</div>
</div>
<a id="a94ada7ff1cf4c2ece889d82f15b01710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ada7ff1cf4c2ece889d82f15b01710">&#9670;&nbsp;</a></span>penaltyBoundToInterval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundToInterval </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ -a &lt; var &lt; a $" src="form_21.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The scalar that should be bounded </td></tr>
    <tr><td class="paramname">a</td><td>lower and upper absolute bound </td></tr>
    <tr><td class="paramname">epsilon</td><td>safty margin (move bound to the interior of the interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehateb__local__planner.html#a15250529ebfe9fe310c0e0dc62617472" title="Derivative of the linear penalty function for bounding var to the interval .">penaltyBoundToIntervalDerivative</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Penalty / cost value that is nonzero if the constraint is not satisfied </dd></dl>

</div>
</div>
<a id="aebe24da4ec2cf8d7e9e4d0ddc667200a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe24da4ec2cf8d7e9e4d0ddc667200a">&#9670;&nbsp;</a></span>penaltyBoundToIntervalDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundToIntervalDerivative </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative of the linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ a &lt; var &lt; b $" src="form_22.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The scalar that should be bounded </td></tr>
    <tr><td class="paramname">a</td><td>lower bound </td></tr>
    <tr><td class="paramname">b</td><td>upper bound </td></tr>
    <tr><td class="paramname">epsilon</td><td>safty margin (move bound to the interior of the interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehateb__local__planner.html#a94ada7ff1cf4c2ece889d82f15b01710" title="Linear penalty function for bounding var to the interval .">penaltyBoundToInterval</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of the penalty function w.r.t. <code>var</code> </dd></dl>

</div>
</div>
<a id="a15250529ebfe9fe310c0e0dc62617472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15250529ebfe9fe310c0e0dc62617472">&#9670;&nbsp;</a></span>penaltyBoundToIntervalDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::penaltyBoundToIntervalDerivative </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derivative of the linear penalty function for bounding <code>var</code> to the interval <img class="formulaInl" alt="$ -a &lt; var &lt; a $" src="form_21.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The scalar that should be bounded </td></tr>
    <tr><td class="paramname">a</td><td>lower and upper absolute bound </td></tr>
    <tr><td class="paramname">epsilon</td><td>safty margin (move bound to the interior of the interval) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacehateb__local__planner.html#a94ada7ff1cf4c2ece889d82f15b01710" title="Linear penalty function for bounding var to the interval .">penaltyBoundToInterval</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of the penalty function w.r.t. <code>var</code> </dd></dl>

</div>
</div>
<a id="a634b06994a4ecb77b1f523162e152c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634b06994a4ecb77b1f523162e152c36">&#9670;&nbsp;</a></span>RegisterStatefulActionNodeROS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void hateb_local_planner::RegisterStatefulActionNodeROS </td>
          <td>(</td>
          <td class="paramtype">BT::BehaviorTreeFactory &amp;&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>registration_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ros::NodeHandle &amp;&#160;</td>
          <td class="paramname"><em>node_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a stateful action node with the behavior tree factory. </p>
<p>This template function creates and registers a builder for derived node types, allowing them to be instantiated by the behavior tree factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The behavior tree factory to register with </td></tr>
    <tr><td class="paramname">registration_ID</td><td>Unique identifier for the node type </td></tr>
    <tr><td class="paramname">node_handle</td><td>ROS node handle for communication </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef51438998773bdbcaed0119e2a62a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef51438998773bdbcaed0119e2a62a4b">&#9670;&nbsp;</a></span>smaller_than_abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hateb_local_planner::smaller_than_abs </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Small helper function: check if |a|&lt;|b|. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a35ec0b46ee5b97db6df35361841f5bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ec0b46ee5b97db6df35361841f5bd2">&#9670;&nbsp;</a></span>goal_vel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Twist hateb_local_planner::goal_vel</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8be0980eee84fa548e6076bbca9a404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be0980eee84fa548e6076bbca9a404c">&#9670;&nbsp;</a></span>isMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hateb_local_planner::isMode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a646388b7d2c05dbfb029b1b00fd67f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646388b7d2c05dbfb029b1b00fd67f23">&#9670;&nbsp;</a></span>nominal_vel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hateb_local_planner::nominal_vel</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44e9e507bb08b55ba047f7edcf443643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e9e507bb08b55ba047f7edcf443643">&#9670;&nbsp;</a></span>start_vel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geometry_msgs::Twist hateb_local_planner::start_vel</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
